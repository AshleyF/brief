assertEqual "lex regular strings" [ 'test "'foo is a" 'this ] [ lex "this \"foo is a\" test" ]
assertEqual "lex tick strings" [ 'baz ''bar 'foo ] [ lex "foo 'bar baz" ]
assertEqual "lex escaped chars" [ "'\b \f \n \r \t  x" ] [ lex "\"\b \f \n \r \t \\ \x\"" ]

assertEqual "parse list" [ this [ 'is 123 a ] test ] [ parse lex "this [ 'is 123 a ] test" ]

let 'whitespace? [ any? swap [ " " '\r '\n '\t ] fry [ = _ ] dup ]

let 'lex [ lex.tokenize rot [ ] [ ] split ]
    let 'lex.tokenize [ cond [ [ lex.done ]                    [ empty? ]
                               [ lex.tokenize lex.token drop ] [ whitespace? snoc ]
                               [ lex.tick lex.addChar ]        [ lex.firstCharIs? '' ]
                               [ lex.str lex.addChar '' drop ] [ lex.firstCharIs? '" ]
                               [ lex.tokenize lex.addChar ] ] ]
    let 'lex.firstCharIs? [ apply fry [ and dip [ = _ dup ] rot 2dip [ empty? ] ] ]
    let 'lex.str [ cond [ [ lex.tokenize lex.token drop ]      [ = '" dup snoc ]
                          [ lex.str lex.addChar lex.unescape ] [ = '\\ dup ]
                          [ lex.str lex.addChar ] ] ]
    let 'lex.tick [ cond [ [ lex.done ]                      [ empty? ]
                       [ lex.tokenize lex.token drop ]       [ whitespace? snoc ]
                       [ lex.tick lex.addChar lex.unescape ] [ = '\\ dup ]
                       [ lex.tick lex.addChar ] ] ]
    let 'lex.unescape [ cond [ [ '\b drop ] [ = 'b dup ]
                               [ '\f drop ] [ = 'f dup ]
                               [ '\n drop ] [ = 'n dup ]
                               [ '\r drop ] [ = 'r dup ]
                               [ '\t drop ] [ = 't dup ] ] snoc drop ]
    let 'lex.done [ 2drop lex.token ]
    let 'lex.addChar [ dip [ cons ] swap ]
    let 'lex.token [ swap [  ] if [ drop ] [ dip [ cons ] swap join reverse ] empty? swap ]

let 'parse [ parse.next swap [  ] ]
    let 'parse.next [ cond [ [ drop ]                         [ empty? ]
                             [ parse.next dip [ cons ] parse drop ] [ = "]" dup snoc ]
                             [ drop ]                         [ or bi [ = "{" ] [ = "[" ] dup ]
                             [ parse.next parse.buildMap parse drop ]     [ = "}" dup ]
                             [ parse.next dip [ cons parse.convert ] swap ] ] ]
    let 'parse.convert [ cond [ [ join tail split ] [ = '' head split dup ]
                                [ nip ]             [ >num? dup ]
                                [ >sym ] ] ]
    let 'parse.buildMap [ parse.buildMap.build rot { } ]
    let 'parse.buildMap.build [ if [ dip [ cons ] swap drop ]
                                   [ parse.buildMap.build dip [ ! swap ] swap snoc swap snoc ] empty? ]

