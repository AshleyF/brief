# 23 DEC 2021 Back to RPN!

[A year ago we switched to prefix notation](https://github.com/AshleyF/brief/blob/gh-pages/sandbox/Language/journal/DEC2020.md#23-dec-2020-reverse-reverse-polish-notation) (heres [the commit](https://github.com/AshleyF/brief/commit/260a761b87c6976ac78be2c69cf1a1e145628cca)) to "to see how it feels for a while." A while is up. I've found it to be confusing and simply could not get used to it. Partly because I'm so used to RPN, Forth, and even the |> and >> operators in F#, but more importantly I believe postfix is the _correct_ way to go.

Much like in English, when saying, "the big, red, bouncy, inflatable... hotdog" it's difficult to build an incremental mental model while reading left-to-right (I bet you were thinking of a ball!). I found myself writing code right-to-left over the past year, just to be able to build and think bottom up. I remember reading Peter Henderson's Lisp book in which he had a habit of (and code syntax for) declaring things in terms of something yet to be defined and then following with "where foo is ...". I hated it.

Just as in F#, I don't like to write `f(g(h x))` and instead write `x |> h |> g |> f`, or better yet when defining a new function use a point-free style, compose with `h >> g >> f`. In Brief, whitespace is the composition operator so it's just `h g f` with a stack threaded through. This makes much more sense to me!

Another reason to prefer postfix is interative development at the REPL. Why should `foo bar [ENTER]` be different to `foo [ENTER]` followed by `bar [ENTER]`? In postfix it's not.

Eventually we may build Intellisence into the REPL or editor, driven by the types on the stack. This works in postfix, but not in prefix (when typed left-to-right at least). For example, Intellisense is why LINQ expressions are phrased `FROM foo SELECT ...` rather than the other way around as it is in SQL. We need to know `FROM` _what_ to drive Intellisense after `SELECT`.

Yet another reason (though a weaker one) is the "natural" infix order of operands around non-commutative operators such as `-` and `/`. For example, to define a `decrement` or a `reciprocal` word in postfix Brief, we define as simply `1 -` and `1 /` respectively. But in _prefix_ Brief we require a `swap` as in `- swap ` and `/ swap 1`. Postfix is more "natural" where `5 1 -` means subtract 1 from 5 and so `1 -` means subtract 1 from something. In prefix `- 1` means subtract something from 1, weird! Even stranger would be to reverse the meaning (`5 - 1` -> `- 1 5`?).

One more reason is that the underlying machine certaintly processes words in a postfix order, even when written in prefix. The internal continuation is a list of tokens in reverse. Now, in postfix Brief, this matches the code and no longer needs to be reversed for display (or when passing a quotation to `set-continuation`).

Some of the word names assumed prefix and we've now swapped their meanings. For example, `prepose` and `compose`. The order of arguments to `if` have been reversed (`<true> <false> if`). It felt more natural to have the name in a `let` expression remain first (`<name> [<definition>] let`).

Finally, the debugger and prompt have been swapped (stack on left, continuation on right, and arrow-*left* to step).

Obviously, all of the existing code in the `prelude.b` and `brief.b`, `serdes.b`, etc. have been updated to postfix notation.

# 24 DEC 2021 Bootstrap

In `Debug` builds, the system begins with F#-defined `lex`/`parse` and `serialize`/`deserialize` primitives and the `prelude.b` is loaded. In `Release` builds only `deserialize` is defined and everything else comes from the `boot.i` image. How to create this image? Launch in `Debug` and:

```brief
clear-dictionary
-1 'prelude.b read lex parse [ ] if
'brief.b open
'serdes.b open
test
'boot.i save-state
exit
```

Clear the dictionary and reload the `prelude.b`. Notice that `open` and event `apply` themselves are undefined. `read lex parse` leaves the structure on the stack and `-1 ... [ ] if` applies it.

Then `open` `brief.b` and `serdes.b` to redefine parsing and serialization in Brief itself. Test everything (`test`) and finally save a new `boot.i`.

Then `exit` and run a `Release` build: `dotnet run --configuration release`.

Voila!
