# 23 DEC 2021 Back to RPN!

[A year ago we switched to prefix notation](https://github.com/AshleyF/brief/blob/gh-pages/sandbox/Language/journal/DEC2020.md#23-dec-2020-reverse-reverse-polish-notation) (heres [the commit](https://github.com/AshleyF/brief/commit/260a761b87c6976ac78be2c69cf1a1e145628cca)) to "to see how it feels for a while." A while is up. I've found it to be confusing and simply could not get used to it. Partly because I'm so used to RPN, Forth, and even the |> and >> operators in F#, but more importantly I believe postfix is the _correct_ way to go.

Much like in English, when saying, "the big, red, bouncy, inflatable... hotdog" it's difficult to build an incremental mental model while reading left-to-right (I bet you were thinking of a ball!). I found myself writing code backward (right-to-left) over the past year, just to be able to build and think bottom up. I remember reading Peter Henderson's Lisp book in which he had a habit of (and code syntax for) declaring things in terms of something yet to be defined and then following with "where foo is ...". I hated it.

Just as in F#, I don't like to write `f(g(h x))` and instead write `x |> h |> g |> f`, or better yet when defining a new function use a point-free style, compose with `h >> g >> f`. In Brief, whitespace is the composition operator so it's just `h g f` with a stack threaded through. This makes much more sense to me!

Another reason to prefer postfix is interative development at the REPL. Why should `foo bar [ENTER]` be different to `foo [ENTER]` followed by `bar [ENTER]`? In postfix it's not.

Eventually we may build Intellisence into the REPL or editor, driven by the types on the stack. This works in postfix, but not in prefix (when typed left-to-right at least). For example, Intellisense is why LINQ expressions are phrased `FROM foo SELECT ...` rather than the other way around as it is in SQL. We need to know `FROM` _what_ to drive Intellisense after `SELECT`.

Yet another reason (though a weaker one) is the "natural" infix order of operands around non-commutative operators such as `-` and `/`. For example, to define a `decrement` or a `reciprocal` word in _postfix_ Brief, we define as simply `1 -` and `1 /` respectively. But in _prefix_ Brief we require a `swap` as in `- swap ` and `/ swap 1`. Postfix is more "natural" where `5 1 -` means subtract 1 from 5 and so `1 -` means subtract 1 from something. In prefix `- 1` means subtract something from 1, weird! Even stranger would be to reverse the meaning (`5 - 1` -> `- 1 5`?).

One more reason is that the underlying machine certaintly processes words in a postfix order, even when written in prefix. The internal continuation is a list of tokens in reverse. Now, in postfix Brief, this matches the code and no longer needs to be reversed for display (or when passing a quotation to `set-continuation`).

Some of the word names assumed prefix and we've now swapped their meanings. For example, `prepose` and `compose`. The order of arguments to `if` have been reversed (`<true> <false> if`). It felt more natural to have the name in a `let` expression remain first (`<name> [<definition>] let`).

Finally, the debugger and prompt have been swapped (stack on left, continuation on right, and arrow-*left* to step).

Obviously, all of the existing code in the `prelude.b` and `brief.b`, `serdes.b`, etc. have been updated to postfix notation.

# 24 DEC 2021 Bootstrap

In `Debug` builds, the system begins with F#-defined `lex`/`parse` and `serialize`/`deserialize` primitives and the `prelude.b` is loaded. In `Release` builds only `deserialize` is defined and everything else comes from the `boot.i` image. How to create this image? Launch in `Debug` and:

```brief
clear-dictionary
-1 'prelude.b read lex parse [ ] if
'brief.b open
'serdes.b open
test
'boot.i save-state
exit
```

Clear the dictionary and reload the `prelude.b`. Notice that `open` and even `apply` themselves are undefined. `read lex parse` leaves the structure on the stack and `-1 ... [ ] if` applies it.

Then `open` `brief.b` and `serdes.b` to redefine parsing and serialization in Brief itself. Test everything (`test`) and finally save a new `boot.i`.

Then `exit` and run a `Release` build: `dotnet run --configuration release`.

Voila!

# 25 DEC 2021 More Compact Syntax

I decided to change the syntax a bit. There's no longer a need to put whitespace after or before the delimiters: `[`, `]`, `{`, `}`. These are now lexed as tokens even when mashed together. This is more like Joy and less like Factor.

So `[foo]` is three tokens, `[]` is two, etc. `1[2 3]4` is equivanent to `1 [ 2 3 ] 4` but conventionally written `1 [2 3] 4` (with space before `[` and after `]` except when followed by another delimiter).

The same is true of Map syntax with  `{'foo 123}` being equivanent to `{ 'foo 123 }`. The latter is still conventionally used, again except when `{` or `}` are followed by another delimiter as in `{}` or `{ 'foo { 'bar 456 }}`, for example.

One confusion is with ticked strings such as `'foo`. If these contain delimiters then the delimeter still becomes a token, so `['foo]` is equivalent to `[ 'foo ]` and even `'foo[bar]` becomes `'foo [ bar ]`. However, ticked delimiters themselves are still allowed! That is `'[ '] '{ '}` is equivalent to `"[" "]" "{" "}"` and  `[']]` is `[ '[ ]` or `[ "]" ]`.  Strangely, `'[bar` becomes `"[" bar` though!

This change has been made in both the F# and Brief-based lexers and all the source had been compacted using the new syntax.

# 26 DEC 2021 Brief in Clojure

2022 will be the "Year of Clojure" for me. I've played a bit with it but have never really given it a real spin. All the while I will be thinking of how it compares to Brief and how I might embed Brief within it.

At 2013 Strange Loop (I was there to see Chuck Moore!), Daniel Gregoire gave a nice [presentation of Gerschwin](https://www.infoq.com/presentations/gershwin/) which is a concatenative language, heavily borrowing from [Factor](http://factorcode.org). The project is [still around](https://gershwin.github.io/) but seems to have been abandoned since 2014. He had to hack the Closure compiler to get the syntax he wanted. I think for Brief, I'll try to stick within Clojure's syntax.

Some observations while reading The Joy of Clojure:

- Clojure Keywords are like Brief Symbols, while Clojure Symbols are like Brief Words
- Clojure Lists are like Brief Quotations, while Clojure Vectors are like Brief Lists
- Clojure primitives include Characters, arbitrary precision numbers, a distinction from fixnum, rationals, `nil`, etc.
- Clojure collections include Sets, a distinction between Lists and Vectors, and lazy sequences
