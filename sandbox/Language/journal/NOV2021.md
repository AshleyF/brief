# 13 NOV 2021 Raw Processing

I decided to change `Raw` to a simple `byte[]`, rather than describing a section of a larger buffer. This is less efficient, but more concrete -- just for now.

# 14 NOV 2021 What Was I Thinking?!

I don't know what I was thinking with all the `Raw` stuff. I ended up creating versions of `cons` and `snoc` to work with `Raw` and started making binary parsing words... I even thought of adding syntax to the language (e.g. 4-bytes `<deadc0de>`).

Then I thought, *what the heck*, we already have all this infrastructure for dealing with `Lists`; `cons`, `snoc`, `compose`, not to mention `map`, `filter`, `fold`, ... Then I thought of adding a `Byte` primitive type, but decided to simply treat them as `Numbers`.

I've changed `load` and `store` to accept and return `Lists` of `Numbers` representing the bytes. Easy as that!

# 15 NOV 2021 Undo

The interpreter is conviently built atop immutable types. It was *very* easy to maintain a list of historical states before applying each line of input in the interpreter. At the interpreter level, I added an `undo` command (similar to `exit` -- not a word, but a special command understood directly by the REPL). This will roll back state. It's quite convenient. I didn't realize how often I'd do a `dup` just to preserve the top of the stack while I tested something out. This preserves the *entire* state.

# 25 NOV 2021 Reorg State and Serialization

## Reorg State

We added words to get and set the whole machine state (`get-state`, `set-state`). Currently this consisets of a stack, a dictionary and a continuation representing code in the process of being executed. Words have been added to get and set these as well (`get-stack`/`set-stack`, `get-dictionary`/`set-dictionary`, `get-continuation`/`set-continuation`). One interesting problem was that the state contains the continuation at the very moment that `get-state` is being called, so this couldn't be used easily to implement `get-continuation` itself as a secondary because it would contain the guts of the definition! Instead, `get-continuation` is a primitive.

Something to note is that the continuation in the actual internal state is a list in _reverse_ order. This is a convenient form for execution; essentially postfix. However, Brief is currently prefix notation (may this should change!) and so to make the continuation look "normal" it is reversed when you `get-` it and reversed again when you `set-` it, either as part of the whole state or directly as a list. This is nice that this makes it a normal quotation.

DEBATE 24: Once again, should Brief remain prefix or change to postfix. I still find myself thinking and writing "backward."

## Reorg Serialization

Just as we have a word to `read` a text file, and `lex` and `parse` it, all bundled into the `open` word, I wanted to reorganize serialization into words to `load` and `save` raw bytes and separate words to `serialize` and `deserialize` values to/from bytes. Then from these, we've added `save-value`/`load-value` which bundle serdes with file I/O. Additionally, using the `get-state` and `set-state` words, we now have `save-state` and `load-state`. The one caveate is that `save-state` doesn't include the continuation because it would contain the guts of the definition itself and we didn't want to make a primitive for it.

It may be a _very_ interesting thing to do though to `get-state` and update the continuation (with `!map `_continuation [ foo bar ]`) to contain code to be executed upon loading an "image."

Next, I want to rewrite binary serialization in Brief!

# 26 NOV 2021 Serialization Redefined In Brief

Serialization is pretty simple in F#, but it would be nice to write it in Brief itself:

```fsharp
let rec serialize (writer: BinaryWriter) =
    let rec write7bit (i: int) =
        if i >= 0x80 then
            writer.Write(byte (i ||| 0x80))
            write7bit (i >>> 7)
        else writer.Write(byte i)
    function
    | Word   w -> writer.Write(0uy); writer.Write(w.Name)
    | Symbol w -> writer.Write(1uy); writer.Write(w)
    | String s -> writer.Write(2uy); writer.Write(s)
    | Number n -> writer.Write(3uy); writer.Write(n)
    | List   l -> writer.Write(4uy); write7bit(l.Length); List.iter (serialize writer) l
    | Map    m ->
        writer.Write(5uy); write7bit(m.Count)
        Map.iter (fun (k: string) v -> writer.Write(k); serialize writer v) m
```

We'll cheat a bit and start with primitives for converting strings to/from UTF-8 (`>utf8`, `utf8>`) and to/from IEEE 754 floating point (`>ieee754`, `ieee754>`).

Let's start with implementing the 7-bit integer encoding. In Brief (in `serdes.b`):

```brief
let 'encode7bit [ reverse encode7bit.encode swap [ ]
    let 'encode7bit.encode [ if [ encode7bit.step ] [ cons ] >= 128 dup ]
    let 'encode7bit.step [ encode7bit.encode trunc >>> 7 keep [ cons or 128 and 127 ] ] ]
```

Serialization is then quite straigh forward and more _brief_ than the F#!

```brief
let 'serialize [ cons cond [
    [ 0 serialize.encode-str >str ]                                           [ word? dup ]
    [ 1 serialize.encode-str >str ]                                           [ sym? dup ]
    [ 2 serialize.encode-str ]                                                [ str? dup ]
    [ 3 >ieee754 ]                                                            [ num? dup ]
    [ 4 compose flatmap [ serialize ] serialize.encode-count ]                [ list? dup ]
    [ 5 compose flatmap [ serialize.keyvalue ] >list serialize.encode-count ] [ map? dup ] ]
    let 'serialize.encode-count [ swap encode7bit count ]
    let 'serialize.keyvalue [ prepose dip [ serialize nip snoc ] serialize.encode-str snoc ]
    let 'serialize.encode-str [ prepose encode7bit count >utf8 ] ]
```

The primitive `serialize` emits `!!! F# Deserialize !!!` to the console so you can clearly see whether you're using the redefined version.

Deserialization should be equally simple, but we can't actually get rid of the need for the F# implementation because what else would load the initial image? We could simplify the format (e.g. no 7-bit int encoding) and use that to load a more complicated and more efficient version.

I've added `#if DEBUG` blocks around the F# serialization and lex/parse code. Automatically, the `DEBUG` build will also load `prelude.b` using the F# lexer and parser. You can then `open 'brief.b` to redefine `lex` and `parse` and can `open 'serdes.b` to redefine `serialize`. Then `save-state 'boot.i' to produce a boot image (copy this to the project root to check in). In `RELEASE` builds this `boot.i` image will be loaded initially instead of the `prelude.b`.

# 27 NOV 2021 `take`, `skip`, `repeat`

In preparation for doing deserializeation in Brief itself, I decided to add a `take` and `skip` words. It turned out to be a good example of what it's like to refactor and simplify in Brief!

Starting with `take`, which will take n-elements from a list into a new list (e.g. `take 3 [ 1 2 3 4 5 ]` goes to `[ 1 2 3 ] [ 4 5 ]`):

```brief
let 'take [ take.rec -rot [ ]
	let 'take.rec [ if [ take.rec dip [ dip [ cons ] swap snoc ] dec ] [ reverse swap drop ] > 0 dup ] ]
```

Then `skip`, which will merely take and discard n-elements (e.g. `skip 3 [ 1 2 3 4 5 ]` goes to `[ 4 5 ]`). It could be implemented as simply `let 'skip [ drop take ]`, but this would inefficiently build a list only to `drop` it. Instead I went with:

```brief
let 'skip [ if [ skip dip [ tail ] dec ] [ drop ] > 0 dup ]
```

Then I thought, you know, the mechanics of decrementing the counter to zero and cleaning up, etc. could be generalized into a `repeat` word, which merely repeatedly applies a quotation n-times (e.g. `repeat [ + 2 ] 3 7` goes to `13`):

```brief
let 'repeat [ if [ repeat 2dip [ apply ] over dec swap ] [ 2drop ] > 0 over ]
```

Then `take` and `skip` can be reduced to:

```brief
let 'take [ reverse swap repeat [ dip [ cons ] swap snoc ] -rot [ ] ]
let 'skip [ repeat [ tail ] ]
```

# 28 NOV 2021 Deserialization Redefined In Brief 

Just as we did for serialization, let's redefine deserialization in Brief itself. The F# version looks like:

```fsharp
let rec deserialize primitives (reader: BinaryReader) =
    let read7bit () =
        let rec read shift i =
            let b = reader.ReadByte()
            let i' = i ||| ((int b &&& 0x7f) <<< shift)
            if b &&& 0x80uy = 0uy then i' else read (shift + 7) i'
        read 0 0
    match reader.ReadByte() with
    | 0uy -> let n = reader.ReadString() in match Map.tryFind n primitives with Some (Word w) -> Word w | _ -> sprintf "Unknown primitive: '%s'" n |> failwith
    | 1uy -> reader.ReadString() |> Symbol
    | 2uy -> reader.ReadString() |> String
    | 3uy -> reader.ReadDouble() |> Number
    | 4uy -> List.init (read7bit ()) (fun _ -> deserialize primitives reader) |> List
    | 5uy -> Seq.init (read7bit ()) (fun _ -> (reader.ReadString(), (deserialize primitives reader))) |> Map.ofSeq |> Map
    | _ -> failwith "Unknown type tag"
```

And in Brief, like:

```brief
let 'decode7bit [ decode7bit.decode dip [ 0 0 ]
    let 'decode7bit.decode [ if [ decode7bit.decode ] [ drop -rot ] decode7bit.step ]
    let 'decode7bit.step [ dip [ dip [ + 7 ] 2dip [ + ] -rot <<< pick ] <> tuck and 127 dup snoc ] ]

let 'deserialize [ nip deserialize.rec
	let 'deserialize.rec [ cond [
		[ find deserialize.decode-str drop ]                                                   [ = 0 dup ]
		[ >sym deserialize.decode-str drop ]                                                   [ = 1 dup ]
		[ deserialize.decode-str drop ]                                                        [ = 2 dup ]
		[ ieee754> take 8 drop ]                                                               [ = 3 dup ]
		[ reverse swap repeat [ dip [ cons ] swap deserialize.rec ] decode7bit swap [ ] drop ] [ = 4 dup ]
		[ swap repeat [ deserialize.keyvalue ] decode7bit swap { } drop ]                      [ = 5 dup ] ] snoc ]
    let 'deserialize.keyvalue [ dip [ ! ] -rot deserialize.rec swap deserialize.decode-str ]
    let 'deserialize.decode-str [ utf8> take decode7bit ] ]
```

Honestly, it's not more _brief_ than the F# code. Also, doing this doesn't help much, in that we still will need the F# implementation in order to load an image containing this re-definition. But it was fun.

I did notice a subtle issue that I'm not certain is a bug or a feature. The following gives an error "Unkown word 'foo", can you guess why?!

```brief
dip [ ] >sym 'foo
```

It's because putting a symbol that represents a valid word on the stack (`>sym '!`) and then attempting to `dip` under it to do some work (or no work in this case), causes the symbol to end up on the program queue. That's how `dip` works -- it tucks _values_ on the program queue while expanding a quotation in front of them. The assumption was that this works fine for _values_ which merely fall back onto the stack. It doesn't work for Symbols representing words -- these are _executed_!

By the way, the same isn't true of Word values. These work fine. For example, `dip [ ] find '!` ends with the word (`(!)`) back on the stack. The confusion is only with Symbols.

# 29 NOV 2021 Clear Dictionary

Added a `clear-dictionary` word that strips all secondary definitions, leaving only primitives.

```brief
let 'clear-dictionary [ set-dictionary >map filter [ word? nip snoc drop snoc ] >list get-dictionary ]
```

We had to also change the main program to use `if parse lex <mycode> [ ] -1` rather than simply `apply parse lex` because `apply` is not a primitive!

This also means that reloading the `prelude.b` is similarly a bit of a pain: `if parse lex read 'prelude.b [ ] -1` rather than `open 'prelude.b`
