# 13 NOV 2021 Raw Processing

I decided to change `Raw` to a simple `byte[]`, rather than describing a section of a larger buffer. This is less efficient, but more concrete -- just for now.

# 14 NOV 2021 What Was I Thinking?!

I don't know what I was thinking with all the `Raw` stuff. I ended up creating versions of `cons` and `snoc` to work with `Raw` and started making binary parsing words... I even thought of adding syntax to the language (e.g. 4-bytes `<deadc0de>`).

Then I thought, *what the heck*, we already have all this infrastructure for dealing with `Lists`; `cons`, `snoc`, `compose`, not to mention `map`, `filter`, `fold`, ... Then I thought of adding a `Byte` primitive type, but decided to simply treat them as `Numbers`.

I've changed `load` and `store` to accept and return `Lists` of `Numbers` representing the bytes. Easy as that!

# 15 NOV 2021 Undo

The interpreter is conviently built atop immutable types. It was *very* easy to maintain a list of historical states before applying each line of input in the interpreter. At the interpreter level, I added an `undo` command (similar to `exit` -- not a word, but a special command understood directly by the REPL). This will roll back state. It's quite convenient. I didn't realize how often I'd do a `dup` just to preserve the top of the stack while I tested something out. This preserves the *entire* state.

# 25 NOV 2021 Reorg State and Serialization

## Reorg State

We added words to get and set the whole machine state (`get-state`, `set-state`). Currently this consisets of a stack, a dictionary and a continuation representing code in the process of being executed. Words have been added to get and set these as well (`get-stack`/`set-stack`, `get-dictionary`/`set-dictionary`, `get-continuation`/`set-continuation`). One interesting problem was that the state contains the continuation at the very moment that `get-state` is being called, so this couldn't be used easily to implement `get-continuation` itself as a secondary because it would contain the guts of the definition! Instead, `get-continuation` is a primitive.

Something to note is that the continuation in the actual internal state is a list in _reverse_ order. This is a convenient form for execution; essentially postfix. However, Brief is currently prefix notation (may this should change!) and so to make the continuation look "normal" it is reversed when you `get-` it and reversed again when you `set-` it, either as part of the whole state or directly as a list. This is nice that this makes it a normal quotation.

DEBATE 24: Once again, should Brief remain prefix or change to postfix. I still find myself thinking and writing "backward."

## Reorg Serialization

Just as we have a word to `read` a text file, and `lex` and `parse` it, all bundled into the `open` word, I wanted to reorganize serialization into words to `load` and `save` raw bytes and separate words to `serialize` and `deserialize` values to/from bytes. Then from these, we've added `save-value`/`load-value` which bundle serdes with file I/O. Additionally, using the `get-state` and `set-state` words, we now have `save-state` and `load-state`. The one caveate is that `save-state` doesn't include the continuation because it would contain the guts of the definition itself and we didn't want to make a primitive for it.

It may be a _very_ interesting thing to do though to `get-state` and update the continuation (with `!map `_continuation [ foo bar ]`) to contain code to be executed upon loading an "image."

Next, I want to rewrite binary serialization in Brief!

# 26 NOV 2021 Serialization Redefined In Brief

Serialization is pretty simple in F#, but it would be nice to write it in Brief itself:

```fsharp
let rec serialize (writer: BinaryWriter) =
    let rec write7bit (i: int) =
        if i >= 0x80 then
            writer.Write(byte (i ||| 0x80))
            write7bit (i >>> 7)
        else writer.Write(byte i)
    function
    | Word   w -> writer.Write(0uy); writer.Write(w.Name)
    | Symbol w -> writer.Write(1uy); writer.Write(w)
    | String s -> writer.Write(2uy); writer.Write(s)
    | Number n -> writer.Write(3uy); writer.Write(n)
    | List   l -> writer.Write(4uy); write7bit(l.Length); List.iter (serialize writer) l
    | Map    m ->
        writer.Write(5uy); write7bit(m.Count)
        Map.iter (fun (k: string) v -> writer.Write(k); serialize writer v) m
```

We'll cheat a bit and start with primitives for converting strings to/from UTF-8 (`>utf8`, `utf8>`) and to/from IEEE 754 floating point (`>ieee754`, `ieee754>`).

Let's start with implementing the 7-bit integer encoding. In Brief (in `serdes.b`):

```brief
let 'encode7bit [ reverse encode7bit.encode swap [ ]
    let 'encode7bit.encode [ if [ encode7bit.step ] [ cons ] >= 128 dup ]
    let 'encode7bit.step [ encode7bit.encode trunc >>> 7 keep [ cons or 128 and 127 ] ] ]
```

Serialization is then quite straigh forward and more _brief_ than the F#!

```brief
let 'serialize [ cons cond [
	[ 0 serialize.encode-str >str ]                                           [ word? dup ]
    [ 1 serialize.encode-str >str ]                                           [ sym? dup ]
    [ 2 serialize.encode-str ]                                                [ str? dup ]
    [ 3 >ieee754 ]                                                            [ num? dup ]
    [ 4 compose flatmap [ serialize ] serialize.encode-count ]                [ list? dup ]
    [ 5 compose flatmap [ serialize.keyvalue ] >list serialize.encode-count ] [ map? dup ] ]
    let 'serialize.encode-count [ swap encode7bit count ]
    let 'serialize.keyvalue [ prepose dip [ serialize nip snoc ] serialize.encode-str snoc ]
	let 'serialize.encode-str [ prepose encode7bit count >utf8 ] ]
```

The primitive `serialize` emits `!!! F# Deserialize !!!` to the console so you can clearly see whether you're using the redefined version.

Deserialization should be equally simple, but we can't actually get rid of the need for the F# implementation because what else would load the initial image? We could simplify the format (e.g. no 7-bit int encoding) and use that to load a more complicated and more efficient version.

I've added `#if DEBUG` blocks around the F# serialization and lex/parse code. Automatically, the `DEBUG` build will also load `prelude.b` using the F# lexer and parser. You can then `open 'brief.b` to redefine `lex` and `parse` and can `open 'serdes.b` to redefine `serialize`. Then `save-state 'boot.i' to produce a boot image (copy this to the project root to check in). In `RELEASE` builds this `boot.i` image will be loaded initially instead of the `prelude.b`.
