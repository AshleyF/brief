# 13 NOV 2021 Raw Processing

I decided to change `Raw` to a simple `byte[]`, rather than describing a section of a larger buffer. This is less efficient, but more concrete -- just for now.

# 14 NOV 2021 What Was I Thinking?!

I don't know what I was thinking with all the `Raw` stuff. I ended up creating versions of `cons` and `snoc` to work with `Raw` and started making binary parsing words... I even thought of adding syntax to the language (e.g. 4-bytes `<deadc0de>`).

Then I thought, *what the heck*, we already have all this infrastructure for dealing with `Lists`; `cons`, `snoc`, `compose`, not to mention `map`, `filter`, `fold`, ... Then I thought of adding a `Byte` primitive type, but decided to simply treat them as `Numbers`.

I've changed `load` and `store` to accept and return `Lists` of `Numbers` representing the bytes. Easy as that!

# 15 NOV 2021 Undo

The interpreter is conviently built atop immutable types. It was *very* easy to maintain a list of historical states before applying each line of input in the interpreter. At the interpreter level, I added an `undo` command (similar to `exit` -- not a word, but a special command understood directly by the REPL). This will roll back state. It's quite convenient. I didn't realize how often I'd do a `dup` just to preserve the top of the stack while I tested something out. This preserves the *entire* state.

# 25 NOV 2021 Reorg State and Serialization

## Reorg State

We added words to get and set the whole machine state (`get-state`, `set-state`). Currently this consisets of a stack, a dictionary and a continuation representing code in the process of being executed. Words have been added to get and set these as well (`get-stack`/`set-stack`, `get-dictionary`/`set-dictionary`, `get-continuation`/`set-continuation`). One interesting problem was that the state contains the continuation at the very moment that `get-state` is being called, so this couldn't be used easily to implement `get-continuation` itself as a secondary because it would contain the guts of the definition! Instead, `get-continuation` is a primitive.

Something to note is that the continuation in the actual internal state is a list in _reverse_ order. This is a convenient form for execution; essentially postfix. However, Brief is currently prefix notation (may this should change!) and so to make the continuation look "normal" it is reversed when you `get-` it and reversed again when you `set-` it, either as part of the whole state or directly as a list. This is nice that this makes it a normal quotation.

DEBATE 24: Once again, should Brief remain prefix or change to postfix. I still find myself thinking and writing "backward."

## Reorg Serialization

Just as we have a word to `read` a text file, and `lex` and `parse` it, all bundled into the `source` word, I wanted to reorganize serialization into words to `load` and `save` raw bytes and separate words to `serialize` and `deserialize` values to/from bytes. Then from these, we've added `save-value`/`load-value` which bundle serdes with file I/O. Additionally, using the `get-state` and `set-state` words, we now have `save-state` and `load-state`. The one caveate is that `save-state` doesn't include the continuation because it would contain the guts of the definition itself and we didn't want to make a primitive for it.

It may be a _very_ interesting thing to do though to `get-state` and update the continuation (with `!map `_continuation [ foo bar ]`) to contain code to be executed upon loading an "image."

Next, I want to rewrite binary serialization in Brief!
